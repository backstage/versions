/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-backstage",
factory: function (require) {
"use strict";var plugin=(()=>{var V=Object.create;var m=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,C=Object.prototype.hasOwnProperty;var M=(e,t,r)=>t in e?m(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var p=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var F=(e,t)=>{for(var r in t)m(e,r,{get:t[r],enumerable:!0})},B=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of U(t))!C.call(e,n)&&n!==r&&m(e,n,{get:()=>t[n],enumerable:!(o=A(t,n))||o.enumerable});return e};var G=(e,t,r)=>(r=e!=null?V(j(e)):{},B(t||!e||!e.__esModule?m(r,"default",{value:e,enumerable:!0}):r,e)),W=e=>B(m({},"__esModule",{value:!0}),e);var E=(e,t,r)=>(M(e,typeof t!="symbol"?t+"":t,r),r);var ee={};F(ee,{default:()=>Z});var R=p("@yarnpkg/core");var w=p("@yarnpkg/core");var f=p("@yarnpkg/core"),l=p("@yarnpkg/fslib"),L=p("semver");var h=G(p("fs")),c=p("path");function D(e,t){let r=e;for(let o=0;o<1e3;o++){let n=(0,c.resolve)(r,"package.json");if(h.default.existsSync(n)&&t(n))return r;let a=(0,c.dirname)(r);if(a===r)return;r=a}throw new Error(`Iteration limit reached when searching for root package.json at ${e}`)}function _(e){let t=D(e,()=>!0);if(!t)throw new Error(`No package.json found while searching for package root of ${e}`);return t}function I(e){if(!h.default.existsSync((0,c.resolve)(e,"src")))throw new Error("Tried to access monorepo package root dir outside of Backstage repository");return(0,c.resolve)(e,"../..")}function P(e){let t=_(e),r=h.default.realpathSync(process.cwd()).replace(/^[a-z]:/,i=>i.toLocaleUpperCase("en-US")),o="",n=()=>(o||(o=I(t)),o),s="",a=()=>(s||(s=D(r,i=>{try{let u=h.default.readFileSync(i,"utf8"),S=JSON.parse(u);return Boolean(S.workspaces)}catch(u){throw new Error(`Failed to parse package.json file while searching for root, ${u}`)}})??r),s);return{ownDir:t,get ownRoot(){return n()},targetDir:r,get targetRoot(){return a()},resolveOwn:(...i)=>(0,c.resolve)(t,...i),resolveOwnRoot:(...i)=>(0,c.resolve)(n(),...i),resolveTarget:(...i)=>(0,c.resolve)(r,...i),resolveTargetRoot:(...i)=>(0,c.resolve)(a(),...i)}}var b="backstage.json";var N="https://versions.backstage.io",J="https://raw.githubusercontent.com/backstage/versions/main";function H(e,t){return new Promise((r,o)=>{let n=setTimeout(()=>{t.aborted||r()},e);t.addEventListener("abort",()=>{clearTimeout(n),o(new Error("Aborted"))})})}async function K(e,t,r){let o=new AbortController,n=new AbortController,s=e(o.signal).then(i=>(n.abort(),i)),a=H(r,n.signal).then(()=>t(n.signal)).then(i=>(o.abort(),i));return Promise.any([s,a]).catch(()=>s)}async function x(e){let t=encodeURIComponent(e.version),r=e.fetch??fetch,o=await K(n=>r(`${N}/v1/releases/${t}/manifest.json`,{signal:n}),n=>r(`${J}/v1/releases/${t}/manifest.json`,{signal:n}),500);if(o.status===404)throw new Error(`No release found for ${e.version} version`);if(o.status!==200)throw new Error(`Unexpected response status ${o.status} when fetching release from ${o.url}.`);return o.json()}var g="backstage:";var v=()=>{let e=l.ppath.resolve(P(l.ppath.cwd()).targetRoot),t=l.xfs.readJsonSync(l.ppath.join(e,b)),r=(0,L.valid)(t.version);if(r===null)throw new Error("Valid version string not found in backstage.json");return r},y=(e,t)=>f.structUtils.bindDescriptor(e,{v:t}),d=async(e,t)=>{let r=f.structUtils.stringifyIdent(e),o=f.structUtils.parseRange(e.range);if(o.protocol!==g)throw new Error(`Unsupported version protocol in version range "${e.range}" for package ${r}`);if(o.selector!=="^")throw new Error(`Unexpected version selector "${o.selector}" for package ${r}`);if(!o.params?.v)throw new Error(`Missing Backstage version parameter in range "${e.range}" for package ${r}`);if(Array.isArray(o.params.v))throw new Error(`Multiple Backstage versions specified in range "${e.range}" for package ${r}`);let s=(await x({version:o.params.v,fetch:async a=>{let i=await f.httpUtils.get(a,{configuration:t,jsonResponse:!0});return{status:200,url:a,json:()=>i}}})).packages.find(a=>a.name===r);if(!s)throw new Error(`Package ${r} not found in manifest for Backstage v${o.selector}. This means the specified package is not included in this Backstage release. This may imply the package has been replaced with an alternative - please review the documentation for the package. If you need to continue using this package, it will be necessary to switch to manually managing its version.`);return s.version};var q=e=>w.structUtils.parseRange(e).protocol===g,z=(e,t,r)=>e!=="dependencies"?e:r.manifest.ensureDependencyMeta(w.structUtils.makeDescriptor(t,"unknown")).optional?"optionalDependencies":e,T=async(e,t)=>{let r=v();for(let o of["dependencies","devDependencies"]){let n=Array.from(e.manifest.getForScope(o).values()).filter(s=>s.range.startsWith(g));for(let s of n){let a=w.structUtils.stringifyIdent(s);if(w.structUtils.parseRange(s.range).selector!=="^")throw new Error(`Unexpected version range "${s.range}" for dependency on "${a}"`);let u=z(o,s,e);t[u][a]=`^${await d(y(s,r),e.project.configuration)}`}}if(["dependencies","devDependencies","optionalDependencies"].some(o=>Object.values(t[o]??{}).some(q)))throw new Error(`Failed to replace all "backstage:" ranges in manifest for ${t.name}`)};var $=p("@yarnpkg/core");var O=class{supportsDescriptor=t=>t.range.startsWith(O.protocol);shouldPersistResolution=()=>!0;bindDescriptor(t){return t.range==="backstage:^"?y(t,v()):t}async getCandidates(t,r,o){return[$.structUtils.makeLocator(t,`npm:${await d(t,o.project.configuration)}`)]}async getSatisfying(t,r,o,n){let s=await d(t,n.project.configuration);return{locators:o.filter(a=>$.structUtils.areIdentsEqual(t,a)&&a.reference===`npm:${s}`),sorted:!0}}supportsLocator=()=>!1;getResolutionDependencies=()=>({});async resolve(){throw new Error("Unreachable")}},k=O;E(k,"protocol",g);var Y="\x1B[31;1m",Q="\x1B[0m";R.semverUtils.satisfiesWithPrereleases(R.YarnVersion,"^4.1.1")||(console.error(),console.error(`${Y}Unsupported yarn version${Q}: The Backstage yarn plugin only works with yarn ^4.1.1. Please upgrade yarn, or remove this plugin with "yarn plugin remove @yarnpkg/plugin-backstage".`),console.error());var X={hooks:{beforeWorkspacePacking:T},resolvers:[k]},Z=X;return W(ee);})();
return plugin;
}
};
